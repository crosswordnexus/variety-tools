<!DOCTYPE html>
<html lang="en">
<!--
* (c) 2024, Crossword Nexus
* MIT License https://mit-license.org/
-->

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crossword Nexus Variety Solver</title>
  <link href="styles.css" rel="stylesheet">

  <!-- Core libs -->
  <script src="lscache.min.js"></script>
  <script src="jscrossword_combined.js"></script>

  <!-- Compression + PDF support -->
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
  <script src="pdf/jspdf-3_0_1.min.js"></script>
  <script src="pdf/grapheme-splitter.min.js"></script>
  <script src="pdf/twemoji.min.js"></script>
  <script src="pdf/xw_pdf.js"></script>
</head>

<body>
  <!-- Overlay for opening puzzles -->
  <div class="cw-open-holder" id="cw-open-holder">
    <div class="cw-overflow"></div>
    <div class="cw-open-puzzle">
      <div class="cw-open-puzzle-instructions">
        Click the button or <strong>drag a .vpuz file here</strong> to open.
      </div>
      <button type="button" class="cw-button info-button" id="open-vpuz-button">
        Open vPuz file
      </button>
    </div>
    <input type="file" class="cw-open-vpuz" id="open-vpuz-input" accept=".vpuz">
  </div>
  <!-- end overlay -->

  <div id="puzzle-container">
    <div id="container">
      <div id="puzzle-image-container">
        <div class="puzzle-image-wrapper">
          <img id="puzzle-image" alt="Puzzle Image">
          <canvas id="canvas"></canvas>
          <div class="button-container" id="button-container">
            <button class="info-button" id="infoButton">Puzzle Info</button>
            <button class="info-button" id="printButton">Print</button>
          </div>
        </div>
      </div>
      <div id="clue-panels">
        <div id="clues-0" class="clue-panel">
          <h2 id="clues-0-title"></h2>
          <ul class="clue-list" id="clue-list-0"></ul>
        </div>
        <div id="clues-1" class="clue-panel">
          <h2 id="clues-1-title"></h2>
          <ul class="clue-list" id="clue-list-1"></ul>
        </div>
      </div>
    </div>

    <!-- Spinner overlay -->
    <div id="spinner-overlay">
      <div class="spinner"></div>
    </div>

    <!-- Modal -->
    <div class="modal" id="infoModal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title" id="modal-title"></h2>
          <span class="modal-close" id="closeModal">&times;</span>
        </div>
        <div class="modal-body" id="modal-body"></div>
      </div>
    </div>
  </div>

  <!-- Load main puzzle logic -->
  <script src="script.js"></script>

  <!-- Inline boot logic -->
  <script type="text/javascript">
    /** Spinner controls **/
    function showSpinner() {
      document.getElementById("spinner-overlay").style.display = "flex";
    }
    function hideSpinner() {
      document.getElementById("spinner-overlay").style.display = "none";
    }

    /** Show puzzle / hide overlay **/
    function showPuzzle() {
      document.getElementById("cw-open-holder").style.display = "none";
      document.getElementById("puzzle-container").style.display = "flex";
    }

    /** Normalize remote puzzle image (optional) **/
    async function normalizeImage(data) {
      const imgSrc = data["puzzle-image"];
      if (imgSrc && /^https?:\/\//i.test(imgSrc)) {
        try {
          const response = await fetch(imgSrc);
          const blob = await response.blob();
          const reader = new FileReader();
          data["puzzle-image"] = await new Promise((resolve, reject) => {
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
          console.log("Fetched & re-encoded image.");
        } catch (err) {
          console.warn("Failed to re-encode hosted image:", err);
        }
      }
      return data;
    }

    /** Load puzzle data with spinner **/
    function loadPuzzleWithSpinner(data) {
      showSpinner();
      loadPuzzle(data);
      const img = document.getElementById("puzzle-image");
      if (!img) return hideSpinner();
      if (img.complete) hideSpinner();
      else {
        img.addEventListener("load", hideSpinner, { once: true });
        img.addEventListener("error", hideSpinner, { once: true });
      }
    }

    /** Read File as JSON and load **/
    function loadJsonFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const json = JSON.parse(e.target.result);
          showPuzzle();
          loadPuzzleWithSpinner(json);
        } catch (err) {
          console.error("Error parsing JSON:", err);
          alert("Could not read that file.");
        }
      };
      reader.onerror = () => console.error("Error reading file:", reader.error);
      reader.readAsText(file);
    }

    document.addEventListener("DOMContentLoaded", function() {
      if (typeof window.fetch !== "function") {
        alert("Please upgrade to a modern browser");
      }

      const openHolder = document.getElementById("cw-open-holder");
      const fileInput = document.getElementById("open-vpuz-input");
      const url = new URL(window.location.href);
      const puzzleParam = url.searchParams.get("puzzle") || url.searchParams.get("file");

      /** Try to load compressed puzzle from hash **/
      function tryLoadFromHash() {
        const hash = window.location.hash.slice(1);
        if (!hash) return false;
        try {
          const jsonText = LZString.decompressFromEncodedURIComponent(hash);
          if (!jsonText) return false;
          const data = JSON.parse(jsonText);
          showPuzzle();
          loadPuzzleWithSpinner(data);
          return true;
        } catch (e) {
          console.error("Failed to decode LZ-hash puzzle:", e);
          return false;
        }
      }

      // 1️⃣ Hash fragment
      if (tryLoadFromHash()) return;

      // 2️⃣ Local upload
      if (!puzzleParam) {
        openHolder.style.display = "flex";

        fileInput.addEventListener("change", (e) => {
          if (e.target.files?.length) loadJsonFile(e.target.files[0]);
        });

        // Drag & drop support
        ["dragover", "dragleave", "drop"].forEach((event) => {
          openHolder.addEventListener(event, (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (event === "dragover") openHolder.classList.add("dragover");
            else openHolder.classList.remove("dragover");
          });
        });

        openHolder.addEventListener("drop", (e) => {
          const files = e.dataTransfer.files;
          if (!files.length) return;
          const file = files[0];
          if (!file.name.endsWith(".vpuz")) {
            alert("Please drop a .vpuz file.");
            return;
          }
          loadJsonFile(file);
        });
      }

      // 3️⃣ Remote fetch (?puzzle= or ?file=)
      else {
        showPuzzle();
        fetch(puzzleParam)
          .then((r) => {
            if (r.ok || r.status === 0) return r.json();
            throw new Error(r.statusText);
          })
          .then(normalizeImage)
          .then(loadPuzzleWithSpinner)
          .catch((err) => console.error("Error fetching puzzle:", err));
      }
    });
  </script>
</body>
</html>
